<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="数据结构-树[TOC] 其他问题二叉树二叉树多少种结果为卡特兰数 https://zh.wikipedia.org/zh-cn/卡塔兰数 与卡特兰数有关问题：  (1)矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(2)一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?(3)有2n个人排成一行进入">
<meta property="og:type" content="article">
<meta property="og:title" content="Yue">
<meta property="og:url" content="http://russell-yy.github.io/2018/10/06/数据结构 树/index.html">
<meta property="og:site_name" content="Yue">
<meta property="og:description" content="数据结构-树[TOC] 其他问题二叉树二叉树多少种结果为卡特兰数 https://zh.wikipedia.org/zh-cn/卡塔兰数 与卡特兰数有关问题：  (1)矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(2)一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?(3)有2n个人排成一行进入">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104043937.png">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/170905/2-1FZ510424EF.png">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/170905/2-1FZ51044001J.png">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/170905/2-1FZ510442J59.png">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ecd3fd3da60aaf7a69196683a15886afbff9d08">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/b195ad016399455a8ecf41e48fe5e02840f07ccc">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d5b386595948cc3167964bcba0caeecd1b55749">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1fb6a754586a754d599f1125efcb06487b0ebde">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1fb6a754586a754d599f1125efcb06487b0ebde">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/5b6328fbe0cded37216c90735c89ee188be26a30">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/71b670ae74954b8aacd4d720d9b2b2081f6d3869">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/597ea9dac049261fdda77c5176b050e6588d6bb9">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d5b386595948cc3167964bcba0caeecd1b55749">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1c759a989c27b474d8493cc9670af77236cad81a">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e3f7521e454dc03236ed8d7677b1af14c0d2cff">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/b496771215763b521288a0439a159f770fea87ec">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251739385617803.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg">
<meta property="og:image" content="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/87be5eefdb8fa8b05d4e77a49222798c08e66318">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/ed580529e822f866d370fa40eff3890fff4fd00b">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/954802d9f6aabb226e79542dc4d910de87c498a9">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/7d0b62de04d508294add0531095118b7a62ca4ce">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/ea31cd12e5e9a33f8121bacd4fa5cd0262507481">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/cb0f3f27bd45fd9443cafc552a6c36e7080109bf">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/954802d9f6aabb226e79542dc4d910de87c498a9">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae">
<meta property="og:image" content="http://russell-yy.github.io/Users/yutiancan/Google%20Drive/previous%20files/实习%20material/interview-master/image/Screen%20Shot%202018-05-03%20at%209.15.13%20AM.png">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/08b2b7b64f0a9e9848ecd3a114cc7dcc8ca6179d">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/eae61ac0f75a6eb01bb7e7b2d50375a78d6a94bf">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/08b2b7b64f0a9e9848ecd3a114cc7dcc8ca6179d">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99">
<meta property="og:updated_time" content="2018-10-07T02:21:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yue">
<meta name="twitter:description" content="数据结构-树[TOC] 其他问题二叉树二叉树多少种结果为卡特兰数 https://zh.wikipedia.org/zh-cn/卡塔兰数 与卡特兰数有关问题：  (1)矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(2)一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?(3)有2n个人排成一行进入">
<meta name="twitter:image" content="http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104043937.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://russell-yy.github.io/2018/10/06/数据结构 树/"/>





  <title> | Yue</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yue</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://russell-yy.github.io/2018/10/06/数据结构 树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yue">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-06T22:21:04-04:00">
                2018-10-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/06/数据结构 树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/10/06/数据结构 树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  18.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  69
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h1><p>[TOC]</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><strong>其他问题</strong></h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树多少种"><a href="#二叉树多少种" class="headerlink" title="二叉树多少种"></a>二叉树多少种</h4><p>结果为<strong>卡特兰数</strong></p>
<p><a href="https://zh.wikipedia.org/zh-cn/卡塔兰数" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/卡塔兰数</a></p>
<p><strong>与卡特兰数有关问题</strong>：</p>
<blockquote>
<p>(1)矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？<br>(2)一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?<br>(3)有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈)<br>(4)将一个凸多边形区域分成三角形区域的方法数?<br>(5)在圆上选择2n个点,将这些点成对连接起来，使得所得到的n条线段不相交的方法数。<br>(6)一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？</p>
</blockquote>
<p>本节要讨论的是当给定 n（n&gt;=0）个结点时，可以构建多少种形态不同的树。</p>
<blockquote>
<p>如果两棵树中各个结点的位置都一一对应，可以说这两棵树相似。如果两棵树不仅相似，而且对应结点上的数据也相同，就可以说这两棵树等价。本节中，形态不同的树指的是互不相似的树。</p>
</blockquote>
<p>前面介绍过，对于任意一棵普通树，通过孩子兄弟表示法的转化，都可以找到唯一的一棵二叉树与之对应。所以本节研究的题目也可以转化成：n 个结点可以构建多少种形态不同的二叉树。</p>
<p>每一棵普通树对应的都是一棵没有右子树的二叉树，所以对于 n 个结点的树来说，树的形态改变是因为除了根结点之外的其它结点改变形态得到的，所以，</p>
<p>n 个结点构建的形态不同的树与之对应的是 n-1 个结点构建的形态不同的二叉树</p>
<p>。</p>
<p>如果 tn</p>
<p> 表示 n 个结点构建的形态不同的树的数量，bn</p>
<p> 表示 n 个结点构建的形态不同的二叉树的数量，则两者之间有这样的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tn=bn-1</span><br></pre></td></tr></table></figure>
<p>方法一</p>
<p>最直接的一种方法就是推理。当 n=0 时，只能构建一棵空树；当 n=2 时，可以构建 2 棵形态不同的二叉树，如图 1（A）；当 n=3 时，可以构建 5 棵形态互不相同的二叉树，如图 1（B）。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170905/2-1FZ5104043937.png" alt="img"><br>图 1 不同形态的二叉树</p>
<p>对于具有 n（ n&gt;1 ）个结点的二叉树来说，都可以看成是一个根结点、由 i 个结点组成的左子树和由 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n-i-1</span><br></pre></td></tr></table></figure>
<p> 个结点组成的右子树。</p>
<blockquote>
<p>当 n=1 时，也适用，只不过只有一个根结点，没有左右孩子（i=0）。</p>
</blockquote>
<p>可以得出一个递推公式：</p>
<p>通过对公式一步步的数学推算，最后得出，含有 n 个结点的不相似的二叉树的数量为：</p>
<p>方法二</p>
<p>从遍历二叉树的角度进行分析，对于任意一棵二叉树来说，它的前序序列和中序序列以及后序序列都是唯一的。其实是这句话还可以倒过来说，只要确定了一棵二叉树的三种遍历序列中的两种，那么这棵二叉树也可以唯一确定。</p>
<p>例如，给定了一个二叉树的前序序列和中序序列分别为：</p>
<p>前序序列：A B C D E F G<br>中序序列：C B E D A F G</p>
<p>可以唯一得到的二叉树如图 2（4）：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170905/2-1FZ510424EF.png" alt="img"><br>图 2 构造二叉树的过程示意图</p>
<p>分析：通过前序序列得知，结点A为二叉树的根结点，结合中序序列，在结点 A 左侧的肯定为其左孩子中的所有结点，右边为右孩子的所有结点，如图 2（1）所示。</p>
<p>再分析 A 结点的左孩子，在前序序列看到，结点 A 后紧跟的是结点 B，由此断定结点 A 的左孩子是 B，再看中序序列，结点 B 左侧只有一个结点 C ，为 B 的左孩子，结点 B 右侧的结点E 和 D 为右孩子，如图 2（2）。</p>
<p>再分析结点 B 的右孩子，前序序列看到，结点 D 在 E 的前边，所有 D 为 B 的右孩子。在中序序列中，结点 E 在 D 前边，说明 E 是 D 的左孩子，如图 2（3）。</p>
<p>最后分析结点 A 的右孩子，由前序序列看到， F 在 G 前边，说明F为根结点。在中序序列中也是如此，说明，G 是 F 的右孩子。如图 2（4）所示。</p>
<p>如果要唯一确定一棵二叉树，必须知道至少两种遍历序列。如果只确定一种序列，无法准确判定二叉树的具体构造。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170905/2-1FZ51044001J.png" alt="img"><br>图 3 前序序列（1，2，3）的二叉树</p>
<p>如图 3 所示为前序序列（1，2，3）构建的不同形态的二叉树，他们的中序序列各不相同。所以不同形态二叉树的数目恰好就是前序序列一定的情况下，所能得到的不同的中序序列的个数。</p>
<p>中序序列是对二叉树进行中序遍历获得的，遍历的过程实质上就是结点数据进栈出栈的过程。所以，中序序列的个数就是数列（1，2，3）按1-2-3的顺序进栈，</p>
<p>各元素选择在不同的时间点出栈，所获的的不同的出栈顺序即为中序序列，而中序序列的数目，也就是不同形态的二叉树的个数。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170905/2-1FZ510442J59.png" alt="img"><br>图 4 中序遍历时进栈和出栈的过程</p>
<p>根据数列中数据的个数 n，所得到的排列顺序的数目为：</p>
<p>通过以上两种方式，都可以知道n个结点能构建的不同形态的二叉树的数量，再结合 tn=bn-1，就可以计算出 n 个结点能构建的不同形态的树的个数。</p>
<p>[TOC]</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree-walk(x)</span><br><span class="line">	<span class="keyword">if</span> x!=nil</span><br><span class="line">    	tree-walk(x.left)</span><br><span class="line">        visit(x)</span><br><span class="line">        tree-walk(x.right)</span><br></pre></td></tr></table></figure>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree-search(x,k)</span><br><span class="line">	<span class="keyword">if</span> x==NIL <span class="keyword">or</span> k==x.key</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">if</span> k&lt;x.key</span><br><span class="line">		<span class="keyword">return</span> tree-search(x.left,k)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> tree-search(x.right,k)</span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree-search(x,k)</span><br><span class="line">	<span class="keyword">while</span> x!=NIL <span class="keyword">and</span> k!=x.key</span><br><span class="line">		<span class="keyword">if</span> k&lt;x.key</span><br><span class="line">			x=x.left</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=x.right</span><br><span class="line">	<span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree-minimum(x)</span><br><span class="line">	<span class="keyword">while</span> x.left!=nil</span><br><span class="line">		x=x.left</span><br><span class="line">	<span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>####后继</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tree-success(x)</span><br><span class="line">	<span class="keyword">if</span> x.right!=nil</span><br><span class="line">		<span class="keyword">return</span> tree-minimum(x.right)</span><br><span class="line">	<span class="comment">#if x.right==nil</span></span><br><span class="line">	y=x.p</span><br><span class="line">	<span class="keyword">while</span> y!=nil <span class="keyword">and</span> x==y.right</span><br><span class="line">		x=y</span><br><span class="line">		y=y.p</span><br><span class="line">	<span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tree-insert(T,z)</span><br><span class="line">	y=nil</span><br><span class="line">	x=T.root</span><br><span class="line">	<span class="keyword">while</span> x!=nil</span><br><span class="line">		y=x</span><br><span class="line">		<span class="keyword">if</span> z.key&lt;x.key</span><br><span class="line">			x=x.left</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			x=x.right</span><br><span class="line">		</span><br><span class="line">	z.p=y</span><br><span class="line">	<span class="keyword">if</span> y==nil</span><br><span class="line">		t.root=z</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> z.key&lt;y.key</span><br><span class="line">		y.left=z</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		y.right=z</span><br></pre></td></tr></table></figure>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用v换u</span></span><br><span class="line">transplant(T,u,v)</span><br><span class="line">	<span class="keyword">if</span> u.p==nil</span><br><span class="line">		T.root=v</span><br><span class="line">	<span class="keyword">elif</span> u==u.p.left</span><br><span class="line">		u.p.left=v</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		u.p.right=v</span><br><span class="line">	<span class="keyword">if</span> v!=nil</span><br><span class="line">		v.p=u.p</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tree-delete(T,z)</span><br><span class="line">	<span class="comment">#如果只有一个孩子，那么直接用孩子来替换</span></span><br><span class="line">	<span class="keyword">if</span> z.left==nil</span><br><span class="line">		transplant(T,z,z.right)</span><br><span class="line">	<span class="keyword">elif</span> z.right==nil</span><br><span class="line">		transplant(T,z,z.right)</span><br><span class="line">	<span class="comment">#使用后继来替换</span></span><br><span class="line">	<span class="keyword">else</span> y=tree-minimum(z.right)</span><br><span class="line">		<span class="keyword">if</span> y.p!=z</span><br><span class="line">			transplant(T,y,y.right)</span><br><span class="line">			y.right=z.right</span><br><span class="line">			y.right.p=y</span><br><span class="line">		transplant(T,z,y)</span><br><span class="line">		y.left=z.left</span><br><span class="line">		y.left.p=y</span><br></pre></td></tr></table></figure>
<p>[TOC]</p>
<p>###AVL（平衡二叉树）</p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>AVL树</strong>是最先发明的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">自平衡二叉查找树</a>。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度</a>都是O(log⁡n)<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99" alt="O(\log{n})">。增加和删除可能需要通过一次或多次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC" target="_blank" rel="noopener">树旋转</a>来重新平衡这个树。AVL树得名于它的发明者<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA" target="_blank" rel="noopener">G. M. Adelson-Velsky</a>和<a href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">E. M. Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中发表了它。</p>
<p>节点的<strong>平衡因子</strong>是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
<p>AVL树的基本操作一般涉及运作同在不平衡的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">二叉查找树</a>所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p>
<p>以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。</p>
<p><a href="https://zh.wikipedia.org/wiki/File:Tree_Rebalancing.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png" alt="avl树旋转的图形描述。"></a></p>
<p>####删除[<a href="https://zh.wikipedia.org/w/index.php?title=AVL%E6%A0%91&amp;action=edit&amp;section=2" target="_blank" rel="noopener">编辑</a>]</p>
<p>从AVL树中删除，可以通过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。因为在旋转成叶子节点期间最多有log <em>n</em>个节点被旋转，而每次AVL旋转耗费固定的时间，所以删除处理在整体上耗费O(log <em>n</em>) 时间。</p>
<p>####搜寻[<a href="https://zh.wikipedia.org/w/index.php?title=AVL%E6%A0%91&amp;action=edit&amp;section=3" target="_blank" rel="noopener">编辑</a>]</p>
<p>可以像普通二叉查找树一样的进行，所以耗费O(log <em>n</em>)时间，因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变。（这是与<a href="https://zh.wikipedia.org/wiki/%E4%BC%B8%E5%B1%95%E6%A8%B9" target="_blank" rel="noopener">伸展树</a>搜寻相对立的，它会因为搜寻而变更树结构。）</p>
<p>####实现描述[<a href="https://zh.wikipedia.org/w/index.php?title=AVL%E6%A0%91&amp;action=edit&amp;section=4" target="_blank" rel="noopener">编辑</a>]</p>
<p>假设平衡因子是左子树的高度减去右子树的高度所得到的值，又假设由于在二叉排序树上插入节点而失去平衡的最小子树根节点的指针为a（即a是离插入点最近，且平衡因子绝对值超过1的祖先节点），则失去平衡后进行的规律可归纳为下列四种情况：</p>
<ol>
<li>单向右旋平衡处理LL：由于在<em>a的左子树根节点的左子树上插入节点，</em>a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作；</li>
<li>单向左旋平衡处理RR：由于在<em>a的右子树根节点的右子树上插入节点，</em>a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作；</li>
<li>双向旋转（先左后右）平衡处理LR：由于在<em>a的左子树根节点的右子树上插入节点，</em>a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。</li>
<li>双向旋转（先右后左）平衡处理RL：由于在<em>a的右子树根节点的左子树上插入节点，</em>a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。</li>
</ol>
<p>在平衡的二叉排序树BBST (Balancing Binary Search Tree)上插入一个新的数据元素e的递归算法可描述如下：</p>
<ol>
<li>若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1；</li>
<li>若e的关键字和BBST的根节点的关键字相等，则不进行；</li>
<li>若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：<ol>
<li>BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度，则将根节点的平衡因子更改为0，BBST的深度不变；</li>
<li>BBST的根节点的平衡因子为0（左、右子树的深度相等）：则将根节点的平衡因子更改为1，BBST的深度增1；</li>
<li>BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：则若BBST的左子树根节点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子树根节点的平衡因子更改为0，树的深度不变；</li>
</ol>
</li>
<li>若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。</li>
</ol>
<p>AVL树的调平（Erlang的实现）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 balance(null) -&gt; null;</span><br><span class="line"> 2 balance(&#123;null, _, null&#125;=Tree) -&gt; Tree;</span><br><span class="line"> 3 balance(&#123;Left, Value, Right&#125;=Tree) -&gt;</span><br><span class="line"> 4 	Diff = count(Left)-count(Right),</span><br><span class="line"> 5 	if (Diff &lt; 2) and (Diff &gt; -2)	-&gt;	&#123;balance(Left), Value, balance(Right)&#125;;</span><br><span class="line"> 6 	   (Diff &gt; 1)				-&gt;	balance(rotate_right(Tree));</span><br><span class="line"> 7 	   (Diff&lt; -1)				-&gt;	balance(rotate_left(Tree));</span><br><span class="line"> 8 	   true					-&gt;	exit(&apos;This is impossible!&apos;)</span><br><span class="line"> 9 	end.</span><br><span class="line">10 </span><br><span class="line">11 rotate_right(&#123;Left, Value, Right&#125;) -&gt;</span><br><span class="line">12 	merge_max(Left, &#123;null, Value, Right&#125;).</span><br><span class="line">13 </span><br><span class="line">14 rotate_left(&#123;Left, Value, Right&#125;) -&gt;</span><br><span class="line">15 	merge_min(Right, &#123;Left, Value, null&#125;).</span><br><span class="line">16 </span><br><span class="line">17 merge_min(&#123;null, Value, Right&#125;, Tree2) -&gt;</span><br><span class="line">18 	&#123;Tree2, Value, Right&#125;;</span><br><span class="line">19 merge_min(&#123;Left, _, _&#125;, Tree2) -&gt;</span><br><span class="line">20 	merge_min(Left, Tree2).</span><br><span class="line">21 </span><br><span class="line">22 merge_max(&#123;Left , Value, null&#125;, Tree2) -&gt;</span><br><span class="line">23 	&#123;Left, Value, Tree2&#125;;</span><br><span class="line">24 merge_max(&#123;_, _, Right&#125;, Tree2) -&gt;</span><br><span class="line">25 	merge_max(Right, Tree2).</span><br></pre></td></tr></table></figure>
<p>####AVL节点数计算[<a href="https://zh.wikipedia.org/w/index.php?title=AVL%E6%A0%91&amp;action=edit&amp;section=5" target="_blank" rel="noopener">编辑</a>]</p>
<p>高度为h的AVL树，节点数N最多2h−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62" alt="2^h -1">； 最少Φh+25−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ecd3fd3da60aaf7a69196683a15886afbff9d08" alt="\frac { \Phi ^{h+2}} {\sqrt{5}} -1 "> ( 其中Φ=1+52=1.618<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b195ad016399455a8ecf41e48fe5e02840f07ccc" alt="\Phi = \frac {1 + \sqrt{5} } {2} = 1.618 "> )。<br>最少节点数n如以费伯纳西数列可以用数学归纳法证明：<br>Nh<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d5b386595948cc3167964bcba0caeecd1b55749" alt="N_h"> = Fh+2<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1fb6a754586a754d599f1125efcb06487b0ebde" alt="F_{h+2}"> - 1 (Fh+2<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1fb6a754586a754d599f1125efcb06487b0ebde" alt="F_{h+2}">是Fibonacci polynomial)。<br>即:<br>N0<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5b6328fbe0cded37216c90735c89ee188be26a30" alt="N_{0}"> = 0 (表示AVL Tree高度为0的节点总数)<br>N1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/71b670ae74954b8aacd4d720d9b2b2081f6d3869" alt="N_{1}"> = 1 (表示AVL Tree高度为1的节点总数)<br>N2<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/597ea9dac049261fdda77c5176b050e6588d6bb9" alt="N_{2}"> = 2 (表示AVL Tree高度为2的节点总数)<br>Nh<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6d5b386595948cc3167964bcba0caeecd1b55749" alt="N_h"> = Nh−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1c759a989c27b474d8493cc9670af77236cad81a" alt="N_{h-1}"> + Nh−2<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e3f7521e454dc03236ed8d7677b1af14c0d2cff" alt="N_{h-2}"> + 1 (表示AVL Tree高度为h的节点总数)<br>换句话说，当节点数为N时，高度h最多为logΦ(5∗(N+1))−2<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b496771215763b521288a0439a159f770fea87ec" alt="log_{\Phi} ( \sqrt{5} *(N+1)) -2 ">。</p>
<p>[TOC]</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>wiki</p>
<p><a href="https://zh.wikipedia.org/wiki/红黑树" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/红黑树</a></p>
<p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>#####定义</p>
<p>满足如下性质的树</p>
<blockquote>
<p>1、每个结点是红色的或者黑色的</p>
<p>2、根结点是黑色的</p>
<p>3、每个叶子结点是黑色的</p>
<p>4、如果一个结点是红色的，那么它的两个子结点都是黑色的</p>
<p>5、对于每个结点，从该结点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。</p>
</blockquote>
<p><strong>注意</strong>：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<h5 id="高度的log证明"><a href="#高度的log证明" class="headerlink" title="高度的log证明"></a>高度的log证明</h5><p>一颗有n个内部结点的红黑树的高度至多为 $$2lg(n+1)$$</p>
<blockquote>
<p>证明：</p>
<p>步骤1：利用数学归纳法证明以任意结点$$x$$为根的子树至少包含$$2^{黑高(x)}-1$$个内部结点。</p>
<p>步骤2：利用性质4，从根结点到叶结点（不包括根结点）的任何一条简单路径上都至少有一半的结点为黑色。从而根结点$$T$$的黑高至少为$$h/2$$</p>
<p>步骤3：从而有$$n&gt;=2^{h/2}-1$$，整理得到$$h&lt;=2log(n+1)$$</p>
</blockquote>
<p><strong>红黑树的时间复杂度为: O(lgn)</strong><br>下面通过“<em>数学归纳法</em>”对红黑树的时间复杂度进行证明。</p>
<p>定理：<strong>一棵含有n个节点的红黑树的高度至多为2log(n+1)</strong>.</p>
<p>证明：<br>    “一棵含有n个节点的红黑树的高度至多为2log(n+1)” 的<strong>逆否命题</strong>是 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。<br>    我们只需要证明逆否命题，即可证明原命题为真；即只需证明 “高度为h的红黑树，它的包含的内节点个数至少为 2h/2-1个”。</p>
<p>​    从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x’s black height)，记为<strong>bh(x)</strong>。关于bh(x)有两点需要说明：<br>    第1点：根据红黑树的”<strong>特性(5)</strong> ，即<em>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</em>“可知，从节点x出发到达的所有的叶节点具有相同数目的黑节点。<strong>这也就意味着，bh(x)的值是唯一的</strong>！<br>    第2点：根据红黑色的”特性(4)，即<em>如果一个节点是红色的，则它的子节点必须是黑色的</em>“可知，从节点x出发达到叶节点”所经历的黑节点数目”&gt;= “所经历的红节点的数目”。假设x是根节点，则可以得出结论”<strong>bh(x) &gt;= h/2</strong>“。进而，我们只需证明 “高度为h的红黑树，它的包含的黑节点个数至少为 2bh(x)-1个”即可。</p>
<p>​    到这里，我们将需要证明的定理已经由<br><strong>“一棵含有n个节点的红黑树的高度至多为2log(n+1)”</strong><br>    转变成只需要证明<br><strong>“高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。</strong></p>
<p>下面通过”数学归纳法”开始论证高度为h的红黑树，它的包含的内节点个数至少为 2bh(x)-1个”。</p>
<p>(01) 当树的高度h=0时，<br>    内节点个数是0，bh(x) 为0，2bh(x)-1 也为 0。显然，原命题成立。</p>
<p>(02) 当h&gt;0，且树的高度为 h-1 时，它包含的节点个数至少为 2bh(x)-1-1。这个是根据(01)推断出来的！</p>
<p>​    下面，由树的高度为 h-1 的已知条件推出“树的高度为 h 时，它所包含的节点树为 2bh(x)-1”。</p>
<p>​    当树的高度为 h 时，<br>    对于节点x(x为根节点)，其黑高度为bh(x)。<br>    对于节点x的左右子树，它们黑高度为 bh(x) 或者 bh(x)-1。<br>    根据(02)的已知条件，我们已知 “x的左右子树，即高度为 h-1 的节点，它包含的节点至少为 2bh(x)-1-1 个”；</p>
<p>​    所以，节点x所包含的节点至少为 ( 2bh(x)-1-1 ) + ( 2bh(x)-1-1 ) + 1 = 2^bh(x)-1。即节点x所包含的节点至少为 2bh(x)-1。<br>    因此，原命题成立。</p>
<p>​    由(01)、(02)得出，”高度为h的红黑树，它的包含的内节点个数至少为 2^bh(x)-1个”。<br>    因此，“一棵含有n个节点的红黑树的高度至多为2log(n+1)”。</p>
<p>红黑树示意图如下：</p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt="img"></a></p>
<p>#####红黑树的应用</p>
<p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。<br>例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html" target="_blank" rel="noopener">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html" target="_blank" rel="noopener">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<p>#####红黑树的基本操作(一) 左旋和右旋</p>
<p>红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。<br>旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对它们进行介绍。</p>
<p><strong>1. 左旋</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg" alt="img"></a></p>
<p>对x进行左旋，意味着”将x变成一个左节点”。</p>
<p>左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)  </span><br><span class="line">01  y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作</span><br><span class="line">02  right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span><br><span class="line">03  p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span><br><span class="line">04  p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”</span><br><span class="line">05  if p[x] = nil[T]       </span><br><span class="line">06  then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span><br><span class="line">07  else if x = left[p[x]]  </span><br><span class="line">08            then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><br><span class="line">09            else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span><br><span class="line">10  left[y] ← x             // 将 “x” 设为 “y的左孩子”</span><br><span class="line">11  p[x] ← y                // 将 “x的父节点” 设为 “y”</span><br></pre></td></tr></table></figure>
<p>理解左旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg" alt="img"></a></p>
<p><strong>2. 右旋</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg" alt="img"></a></p>
<p>对x进行左旋，意味着”将x变成一个左节点”。</p>
<p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)  </span><br><span class="line">01  x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作</span><br><span class="line">02  left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span><br><span class="line">03  p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span><br><span class="line">04  p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”</span><br><span class="line">05  if p[y] = nil[T]       </span><br><span class="line">06  then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span><br><span class="line">07  else if y = right[p[y]]  </span><br><span class="line">08            then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span><br><span class="line">09            else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span><br><span class="line">10  right[x] ← y            // 将 “y” 设为 “x的右孩子”</span><br><span class="line">11  p[y] ← x                // 将 “y的父节点” 设为 “x”</span><br></pre></td></tr></table></figure>
<p>理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg" alt="img"></a></p>
<p><strong>旋转总结</strong>：</p>
<p>(01) 左旋 和 右旋 是相对的两个概念，原理类似。理解一个也就理解了另一个。</p>
<p>(02) 下面谈谈如何区分 左旋 和 右旋。<br>在实际应用中，若没有彻底理解 左旋 和 右旋，可能会将它们混淆。下面谈谈我对如何区分 左旋 和 右旋 的理解。</p>
<p><strong>3. 区分 左旋 和 右旋</strong></p>
<p>仔细观察上面”左旋”和”右旋”的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。</p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251739385617803.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251739385617803.jpg" alt="img"></a></p>
<p><strong>左旋示例图</strong>(以x为节点进行左旋)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              z</span><br><span class="line">  x                          /                  </span><br><span class="line"> / \      --(左旋)--&gt;       x</span><br><span class="line">y   z                      /</span><br><span class="line">                          y</span><br></pre></td></tr></table></figure>
<p>对x进行左旋，意味着，将“x的右孩子”设为“x的父亲节点”；即，将 x变成了一个左节点(x成了为z的左孩子)！。 因此，<strong>左旋中的“左”，意味着“被旋转的节点将变成一个左节点”</strong>。</p>
<p><strong>右旋示例图</strong>(以x为节点进行右旋)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              y</span><br><span class="line">  x                            \                 </span><br><span class="line"> / \      --(右旋)--&gt;           x</span><br><span class="line">y   z                            \</span><br><span class="line">                                  z</span><br></pre></td></tr></table></figure>
<p>对x进行右旋，意味着，将“x的左孩子”设为“x的父亲节点”；即，将 x变成了一个右节点(x成了为y的右孩子)！ 因此，<strong>右旋中的“右”，意味着“被旋转的节点将变成一个右节点”</strong>。</p>
<p>#####红黑树的基本操作(二) 添加</p>
<p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
<p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p><strong>第二步：将插入的节点着色为”红色”。</strong><br>       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>       将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈</p>
<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>       第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>       对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>       对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>       对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>       对于”特性(4)”，是有可能违背的！<br>       那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<p>下面看看代码到底是怎样实现这三步的。</p>
<p>添加操作的伪代码《算法导论》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T, z)  </span><br><span class="line">01  y ← nil[T]                        // 新建节点“y”，将y设为空节点。</span><br><span class="line">02  x ← root[T]                       // 设“红黑树T”的根节点为“x”</span><br><span class="line">03  while x ≠ nil[T]                  // 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="line">04      do y ← x                      </span><br><span class="line">05         if key[z] &lt; key[x]  </span><br><span class="line">06            then x ← left[x]  </span><br><span class="line">07            else x ← right[x]  </span><br><span class="line">08  p[z] ← y                          // 设置 “z的父亲” 为 “y”</span><br><span class="line">09  if y = nil[T]                     </span><br><span class="line">10     then root[T] ← z               // 情况1：若y是空节点，则将z设为根</span><br><span class="line">11     else if key[z] &lt; key[y]        </span><br><span class="line">12             then left[y] ← z       // 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span><br><span class="line">13             else right[y] ← z      // 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span><br><span class="line">14  left[z] ← nil[T]                  // z的左孩子设为空</span><br><span class="line">15  right[z] ← nil[T]                 // z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span><br><span class="line">16  color[z] ← RED                    // 将z着色为“红色”</span><br><span class="line">17  RB-INSERT-FIXUP(T, z)             // 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br></pre></td></tr></table></figure>
<p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p>
<p>添加修正操作的伪代码《算法导论》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line">01 while color[p[z]] = RED                                                  // 若“当前节点(z)的父节点是红色”，则进行以下处理。</span><br><span class="line">02     do if p[z] = left[p[p[z]]]                                           // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="line">03           then y ← right[p[p[z]]]                                        // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span><br><span class="line">04                if color[y] = RED                                         // Case 1条件：叔叔是红色</span><br><span class="line">05                   then color[p[z]] ← BLACK                    ▹ Case 1   //  (01) 将“父节点”设为黑色。</span><br><span class="line">06                        color[y] ← BLACK                       ▹ Case 1   //  (02) 将“叔叔节点”设为黑色。</span><br><span class="line">07                        color[p[p[z]]] ← RED                   ▹ Case 1   //  (03) 将“祖父节点”设为“红色”。</span><br><span class="line">08                        z ← p[p[z]]                            ▹ Case 1   //  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="line">09                   else if z = right[p[z]]                                // Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="line">10                           then z ← p[z]                       ▹ Case 2   //  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="line">11                                LEFT-ROTATE(T, z)              ▹ Case 2   //  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="line">12                           color[p[z]] ← BLACK                 ▹ Case 3   // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="line">13                           color[p[p[z]]] ← RED                ▹ Case 3   //  (02) 将“祖父节点”设为“红色”。</span><br><span class="line">14                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3   //  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="line">15        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)      // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="line">16 color[root[T]] ← BLACK</span><br></pre></td></tr></table></figure>
<p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。<br>    处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。<br>    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。<br>    处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td>(01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td>(01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td>(01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody>
</table>
<p>上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。</p>
<p><strong>1. (Case 1)叔叔是红色</strong></p>
<p><strong>1.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p>
<p><strong>1.2 处理策略</strong><br>(01) 将“父节点”设为黑色。<br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</p>
<p>​    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>    “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。<br>    但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>    按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p>
<p><strong>1.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" target="_blank" rel="noopener"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="img"></strong></a></p>
<p><strong>2. (Case 2)叔叔是黑色，且当前节点是右孩子</strong></p>
<p><strong>2.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p>
<p><strong>2.2 处理策略</strong><br>(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</p>
<p>​      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>      首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>      按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p>
<p><strong>2.2 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" target="_blank" rel="noopener"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt="img"></strong></a></p>
<p><strong>3. (Case 3)叔叔是黑色，且当前节点是左孩子</strong></p>
<p><strong>3.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p>
<p><strong>3.2 处理策略</strong><br>(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</p>
<p>​      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>      为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>      S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p>
<p><strong>2.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt="img"></a></p>
<p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p>
<p>#####红黑树的基本操作(三) 删除</p>
<p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<p><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>       这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>       ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>       ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>       ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p>
<p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>       因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作的伪代码《算法导论》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T, z)</span><br><span class="line">01 if left[z] = nil[T] or right[z] = nil[T]         </span><br><span class="line">02    then y ← z                                  // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；</span><br><span class="line">03    else y ← TREE-SUCCESSOR(z)                  // 否则，将“z的后继节点”赋值给 “y”。</span><br><span class="line">04 if left[y] ≠ nil[T]</span><br><span class="line">05    then x ← left[y]                            // 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；</span><br><span class="line">06    else x ← right[y]                           // 否则，“y的右孩子” 赋值给 “x”。</span><br><span class="line">07 p[x] ← p[y]                                    // 将“y的父节点” 设置为 “x的父节点”</span><br><span class="line">08 if p[y] = nil[T]                               </span><br><span class="line">09    then root[T] ← x                            // 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。</span><br><span class="line">10    else if y = left[p[y]]                    </span><br><span class="line">11            then left[p[y]] ← x                 // 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”</span><br><span class="line">12            else right[p[y]] ← x                // 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”</span><br><span class="line">13 if y ≠ z                                    </span><br><span class="line">14    then key[z] ← key[y]                        // 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！</span><br><span class="line">15         copy y&apos;s satellite data into z         </span><br><span class="line">16 if color[y] = BLACK                            </span><br><span class="line">17    then RB-DELETE-FIXUP(T, x)                  // 若“y为黑节点”，则调用</span><br><span class="line">18 return y</span><br></pre></td></tr></table></figure>
<p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T, x)</span><br><span class="line">01 while x ≠ root[T] and color[x] = BLACK  </span><br><span class="line">02     do if x = left[p[x]]      </span><br><span class="line">03           then w ← right[p[x]]                                             // 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          </span><br><span class="line">04                if color[w] = RED                                           // Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</span><br><span class="line">05                   then color[w] ← BLACK                        ▹  Case 1   //   (01) 将x的兄弟节点设为“黑色”。</span><br><span class="line">06                        color[p[x]] ← RED                       ▹  Case 1   //   (02) 将x的父节点设为“红色”。</span><br><span class="line">07                        LEFT-ROTATE(T, p[x])                    ▹  Case 1   //   (03) 对x的父节点进行左旋。</span><br><span class="line">08                        w ← right[p[x]]                         ▹  Case 1   //   (04) 左旋后，重新设置x的兄弟节点。</span><br><span class="line">09                if color[left[w]] = BLACK and color[right[w]] = BLACK       // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</span><br><span class="line">10                   then color[w] ← RED                          ▹  Case 2   //   (01) 将x的兄弟节点设为“红色”。</span><br><span class="line">11                        x ←  p[x]                               ▹  Case 2   //   (02) 设置“x的父节点”为“新的x节点”。</span><br><span class="line">12                   else if color[right[w]] = BLACK                          // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</span><br><span class="line">13                           then color[left[w]] ← BLACK          ▹  Case 3   //   (01) 将x兄弟节点的左孩子设为“黑色”。</span><br><span class="line">14                                color[w] ← RED                  ▹  Case 3   //   (02) 将x兄弟节点设为“红色”。</span><br><span class="line">15                                RIGHT-ROTATE(T, w)              ▹  Case 3   //   (03) 对x的兄弟节点进行右旋。</span><br><span class="line">16                                w ← right[p[x]]                 ▹  Case 3   //   (04) 右旋后，重新设置x的兄弟节点。</span><br><span class="line">17                         color[w] ← color[p[x]]                 ▹  Case 4   // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。</span><br><span class="line">18                         color[p[x]] ← BLACK                    ▹  Case 4   //   (02) 将x父节点设为“黑色”。</span><br><span class="line">19                         color[right[w]] ← BLACK                ▹  Case 4   //   (03) 将x兄弟节点的右子节设为“黑色”。</span><br><span class="line">20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4   //   (04) 对x的父节点进行左旋。</span><br><span class="line">21                         x ← root[T]                            ▹  Case 4   //   (05) 设置“x”为“根节点”。</span><br><span class="line">22        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)        // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="line">23 color[x] ← BLACK</span><br></pre></td></tr></table></figure>
<p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>​      前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>      为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>      通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>      现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p>
<p>​      现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p>
<p>将上面的姿态，可以概括为3种情况。<br>① 情况说明：x是“红+黑”节点。<br>    处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明：x是“黑+黑”节点，且x是根。<br>    处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明：x是“黑+黑”节点，且x不是根。<br>    处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Case 1</strong></td>
<td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td>
<td>(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。(04) 左旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 2</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td>
<td>(01) 将x的兄弟节点设为“红色”。(02) 设置“x的父节点”为“新的x节点”。</td>
</tr>
<tr>
<td><strong>Case 3</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td>
<td>(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。(04) 右旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 4</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td>
<td>(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。</td>
</tr>
</tbody>
</table>
<p><strong>1. (Case 1)x是”黑+黑”节点，x的兄弟节点是红色</strong></p>
<p><strong>1.1 现象说明</strong><br>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p>
<p><strong>1.2 处理策略</strong><br>(01) 将x的兄弟节点设为“黑色”。<br>(02) 将x的父节点设为“红色”。<br>(03) 对x的父节点进行左旋。<br>(04) 左旋后，重新设置x的兄弟节点。</p>
<p>​      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>      这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>1.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" alt="img"></a></p>
<p><strong>2. (Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></p>
<p><strong>2.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p>
<p><strong>2.2 处理策略</strong><br>(01) 将x的兄弟节点设为“红色”。<br>(02) 设置“x的父节点”为“新的x节点”。</p>
<p>​      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>      这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>      经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p>
<p><strong>2.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" target="_blank" rel="noopener"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" alt="img"></strong></a></p>
<p><strong>3. (Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></p>
<p><strong>3.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
<p><strong>3.2 处理策略</strong><br>(01) 将x兄弟节点的左孩子设为“黑色”。<br>(02) 将x兄弟节点设为“红色”。<br>(03) 对x的兄弟节点进行右旋。<br>(04) 右旋后，重新设置x的兄弟节点。</p>
<p>​       <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>       我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>3.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" target="_blank" rel="noopener"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" alt="img"></strong></a></p>
<p><strong>4. (Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></p>
<p><strong>4.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p>
<p><strong>4.2 处理策略</strong><br>(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>(02) 将x父节点设为“黑色”。<br>(03) 将x兄弟节点的右子节设为“黑色”。<br>(04) 对x的父节点进行左旋。<br>(05) 设置“x”为“根节点”。</p>
<p>​      <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>      我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>      为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>      我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>      第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>             若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>      第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>             若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>      第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>             在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p>
<p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p>
<p><strong>4.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" alt="img"></a></p>
<p>[TOC]</p>
<h3 id="顺序统计树"><a href="#顺序统计树" class="headerlink" title="顺序统计树"></a>顺序统计树</h3><p>在红黑树中结点 $$x$$ 中添加属性 $$x.size$$，包含了以x为根的子树（包括x本身）的（内）结点个数，即这个子树的大小。</p>
<p>一个元素在集合线性序中的位置叫做这个元素的秩</p>
<h4 id="查找具有给定秩的元素"><a href="#查找具有给定秩的元素" class="headerlink" title="查找具有给定秩的元素"></a>查找具有给定秩的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os-select(x,i)</span><br><span class="line">	r=x.left.size + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> i==r</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	<span class="keyword">elif</span> i&lt;r</span><br><span class="line">		<span class="keyword">return</span> os-select(x.left, i)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> os-select(x.right, i-r)</span><br></pre></td></tr></table></figure>
<h4 id="确定一个元素的秩"><a href="#确定一个元素的秩" class="headerlink" title="确定一个元素的秩"></a>确定一个元素的秩</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">os-rank(T, x)</span><br><span class="line">	r=x.left.size+<span class="number">1</span></span><br><span class="line">	y=x</span><br><span class="line">	<span class="keyword">while</span> y!=T.root</span><br><span class="line">		<span class="keyword">if</span> y==y.p.right</span><br><span class="line">			r=r+y.p.left.size+<span class="number">1</span></span><br><span class="line">		y=y.p</span><br><span class="line">	<span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>秩在红黑树旋转的时候维护</p>
<h3 id="区间树（线段树）"><a href="#区间树（线段树）" class="headerlink" title="区间树（线段树）"></a>区间树（线段树）</h3><p>在红黑树中结点 $$x$$ 中添加属性 $$x.int.low$$ 、$$x.int.high$$ 、$$x.max$$</p>
<p>$$x.max$$表示以x为根的子树中所有区间的端点的最大值</p>
<h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>$$x.max=max(x.int.high, x.left.max, x.right.max)$$</p>
<p>如果只是旋转可以在$$O(lg n)$$时间完成。</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>找出树T中与区间 $$i$$ 重叠的那个结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interval-search()</span><br><span class="line">	x=T.root</span><br><span class="line">	while x!=T.nil and i does not overlap x.int</span><br><span class="line">		if x.left!=T.nil and x.left.max&gt;= i.low</span><br><span class="line">			x=x.left</span><br><span class="line">		else</span><br><span class="line">			x=x.right</span><br></pre></td></tr></table></figure>
<p>[TOC]</p>
<h3 id="B树（平衡多路查找树）"><a href="#B树（平衡多路查找树）" class="headerlink" title="B树（平衡多路查找树）"></a>B树（平衡多路查找树）</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>B树</strong>（英语：B-tree）是一种自平衡的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">树</a>)，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#%E5%AF%B9%E6%95%B0%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">对数时间</a>内完成。B树，概括来说是一个一般化的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">二叉查找树</a>（binary search tree），可以拥有多于2个子节点。与<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">自平衡二叉查找树</a>不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">数据库</a>和<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">文件系统</a>的实现上。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th></th>
<th><strong>平均</strong></th>
<th><strong>最差</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>空间</td>
<td></td>
<td>O(<em>n</em>)</td>
<td>O(<em>n</em>)</td>
</tr>
<tr>
<td>搜索</td>
<td></td>
<td>O(log <em>n</em>)</td>
<td>O(log <em>n</em>)</td>
</tr>
<tr>
<td>插入</td>
<td></td>
<td>O(log <em>n</em>)</td>
<td>O(log <em>n</em>)</td>
</tr>
<tr>
<td>删除</td>
<td></td>
<td>O(log <em>n</em>)</td>
<td>O(log <em>n</em>)</td>
</tr>
</tbody>
</table>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ol>
<li>树中每个结点最多含有m个孩子（m&gt;=2）；</li>
<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>
<li>根结点至少有2个孩子（除非B树只包含一个结点：根结点）；</li>
<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。</li>
<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a) Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。<br>b) Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。<br>c) 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。</li>
</ol>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><p>针对一棵高度为h的m阶B树，插入一个元素时，首先在B树中是否存在，如果不存在，一般在叶子结点中插入该新的元素，此时分3种情况：</p>
<ul>
<li>如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；</li>
<li>如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该<strong>结点</strong>进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。</li>
<li>此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</li>
</ul>
<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除操作相对于插入操作要考虑的情况多点。</p>
<ul>
<li>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点</li>
<li>如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；</li>
<li>如果没有，直接删除后，移动之后的情况。</li>
</ul>
<p>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于<strong>ceil(m/2)-1</strong>，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）</p>
<ul>
<li>如果丰满，则向父节点借一个元素来满足条件；</li>
<li>如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。</li>
</ul>
<p>[TOC]</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>B+ 树</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">树数据结构</a>)，通常用于<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">数据库</a>和<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a>的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">文件系统</a>中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">二叉树</a>恰好相反。</p>
<p><a href="https://en.wikipedia.org/wiki/B%2B_tree#Overview" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B%2B_tree#Overview</a></p>
<h4 id="与B树区别"><a href="#与B树区别" class="headerlink" title="与B树区别"></a>与B树区别</h4><p>1.</p>
<blockquote>
<p>（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加；</p>
<p>（2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接；</p>
<p>（3）B+树的根节点关键字数量和其子节点个数相等;</p>
<p>（4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</p>
</blockquote>
<p>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)</p>
<p>3.<strong>所有的非终端结点可以看成是索引部分</strong>，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
<h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><p>在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少 ⌊m/2⌋<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87be5eefdb8fa8b05d4e77a49222798c08e66318" alt="\lfloor m/2\rfloor "> 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。</p>
<p>每个内部节点的元素充当分开它的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%90%E6%A0%91&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">子树</a>的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素 <em>a</em>1 和 <em>a</em>2。在最左子树中所有的值都小于等于 <em>a</em>1，在中间子树中所有的值都在 <em>a</em>1 和 <em>a</em>2 之间((<em>a</em>1，<em>a</em>2]），而在最右子树中所有的值都大于 <em>a</em>2。</p>
<p>The order, or branching factor, b of a B+ tree measures the capacity of nodes (i.e., the number of children nodes) for internal nodes in the tree. The actual number of children for a node, referred to here as m, is constrained for internal nodes so that<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ed580529e822f866d370fa40eff3890fff4fd00b" alt="\lceil b/2\rceil \leq m\leq b">. The root is an exception: it is allowed to have as few as two children.<a href="https://en.wikipedia.org/wiki/B%2B_tree#cite_note-Navathe-1" target="_blank" rel="noopener">[1]</a> For example, if the <a href="https://en.wikipedia.org/wiki/Order_(graph_theory" target="_blank" rel="noopener">order</a>) of a B+ tree is 7, each <a href="https://en.wikipedia.org/wiki/Internal_node" target="_blank" rel="noopener">internal node</a>(except for the root) may have between 4 and 7 children; the root may have between 2 and 7. Leaf nodes have no children, but are constrained so that the number of keys must be at least <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/954802d9f6aabb226e79542dc4d910de87c498a9" alt="\lceil b/2\rceil -1">and at most<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae" alt="b-1">. In the situation where a B+ tree is nearly empty, it only contains one node, which is a leaf node. (The root is also the single leaf, in this case.) This node is permitted to have as little as one key if necessary and at most <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae" alt="b-1">.</p>
<table>
<thead>
<tr>
<th>Node Type</th>
<th>Children Type</th>
<th>Min Number of Children</th>
<th>Max Number of Children</th>
<th>Example b=7<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7d0b62de04d508294add0531095118b7a62ca4ce" alt="{\displaystyle b=7}"></th>
<th>Example b=100<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ea31cd12e5e9a33f8121bacd4fa5cd0262507481" alt="{\displaystyle b=100}"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Root Node (when it is the only node in the tree)</td>
<td>Records</td>
<td>1</td>
<td>b−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae" alt="b-1"></td>
<td>1–6</td>
<td>1–99</td>
</tr>
<tr>
<td>Root Node</td>
<td>Internal Nodes or Leaf Nodes</td>
<td>2</td>
<td>b</td>
<td>2–7</td>
<td>2–100</td>
</tr>
<tr>
<td>Internal Node</td>
<td>Internal Nodes or Leaf Nodes</td>
<td>⌈b/2⌉<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cb0f3f27bd45fd9443cafc552a6c36e7080109bf" alt="\lceil b/2\rceil "></td>
<td>b</td>
<td>4–7</td>
<td>50–100</td>
</tr>
<tr>
<td>Leaf Node</td>
<td>Records</td>
<td>⌈b/2⌉−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/954802d9f6aabb226e79542dc4d910de87c498a9" alt="\lceil b/2\rceil -1"></td>
<td>b−1<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1bf4269308d5f8175c0de6c3d7d9dc177e4f1cae" alt="b-1"></td>
<td>3–6</td>
<td>49–99</td>
</tr>
</tbody>
</table>
<p>####查找[<a href="https://zh.wikipedia.org/w/index.php?title=B%2B%E6%A0%91&amp;action=edit&amp;section=3" target="_blank" rel="noopener">编辑</a>]</p>
<p>查找以典型的方式进行，类似于<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">二叉查找树</a>。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">二分查找</a>来确定这个位置。</p>
<p>####插入[<a href="https://zh.wikipedia.org/w/index.php?title=B%2B%E6%A0%91&amp;action=edit&amp;section=4" target="_blank" rel="noopener">编辑</a>]</p>
<p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p>
<ol>
<li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li>
</ol>
<p>####删除[<a href="https://zh.wikipedia.org/w/index.php?title=B%2B%E6%A0%91&amp;action=edit&amp;section=5" target="_blank" rel="noopener">编辑</a>]</p>
<ol>
<li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li>
<li>如果没有节点处于违规状态则处理结束。</li>
<li>如果节点处于违规状态则有两种可能情况：<ol>
<li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li>
<li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li>
</ol>
</li>
</ol>
<p>####为什么说<a href=""><strong>B+-tree</strong></a>比B 树更适合实际应用中操作系统的文件索引和数据库索引</p>
<p>1) B+-tree的磁盘读写代价更低</p>
<p><a href=""><strong>B+-tree</strong></a>的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>​    举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶<a href="">B-tree</a>(一个结点最多8个关键字)的内部结点需要2个盘快。而<strong>B+</strong> 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比<strong>B+</strong> 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
<p>2) B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>个人觉得这两个原因都不是主要原因。数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B* 树"></a>B* 树</h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为<strong>（cei(2/3*m)）</strong></p>
<p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p>
<p>特点：</p>
<p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</p>
<p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；</p>
<p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>计算机科学中，<strong>2–3树</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">树型数据结构</a>)，内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素</p>
<p>可以看成是阶为3的B树</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="/Users/yutiancan/Google Drive/previous files/实习 material/interview-master/image/Screen Shot 2018-05-03 at 9.15.13 AM.png" alt="Screen Shot 2018-05-03 at 9.15.13 AM"></p>
<h3 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h3><p><strong>2-3-4 树</strong>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中是阶为 4 的<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">B树</a>。</p>
<p>[TOC]</p>
<h3 id="treap-树堆"><a href="#treap-树堆" class="headerlink" title="treap 树堆"></a>treap 树堆</h3><p>Treap=<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">Tree</a>)+<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="noopener">Heap</a>。Treap本身是一棵<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>，它的左子树和右子树也分别是一个Treap，和一般的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>不同的是，Treap纪录一个额外的数据，就是优先级。Treap在以关键码构成<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>的同时，还满足<a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">堆</a>)的性质。Treap维护堆性质的方法用到了旋转，只需要两种旋转，编程复杂度比<a href="https://zh.wikipedia.org/wiki/Splay" target="_blank" rel="noopener">Splay</a>要小一些。</p>
<p>####插入[<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%91%E5%A0%86&amp;action=edit&amp;section=2" target="_blank" rel="noopener">编辑</a>]</p>
<p>给节点随机分配一个优先级，先和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>的插入一样，先把要插入的点插入到一个叶子上，然后跟维护堆一样，如果当前节点的优先级比根大就旋转，如果当前节点是根的左儿子就右旋如果当前节点是根的右儿子就左旋。</p>
<p>由于旋转是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" alt="O(1)">的，最多进行h次（h是树的高度），插入的复杂度是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08b2b7b64f0a9e9848ecd3a114cc7dcc8ca6179d" alt="O(h)">的，在期望情况下<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eae61ac0f75a6eb01bb7e7b2d50375a78d6a94bf" alt="h=O(\log {n})">，所以它的期望复杂度是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99" alt="O(\log{n})">。</p>
<p>####删除[<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%91%E5%A0%86&amp;action=edit&amp;section=3" target="_blank" rel="noopener">编辑</a>]</p>
<p>因为Treap满足堆性质，所以只需要把要删除的节点旋转到叶节点上，然后直接删除就可以了。具体的方法就是每次找到优先级最大的儿子，向与其相反的方向旋转，直到那个节点被旋转到了叶节点，然后直接删除。</p>
<p>删除最多进行<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08b2b7b64f0a9e9848ecd3a114cc7dcc8ca6179d" alt="O(h)">次旋转，期望复杂度是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99" alt="O(\log{n})">。</p>
<p>####查找[<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%91%E5%A0%86&amp;action=edit&amp;section=4" target="_blank" rel="noopener">编辑</a>]</p>
<p>和一般的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>一样，但是由于Treap的随机化结构，Treap中查找的期望复杂度是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99" alt="O(\log{n})">。</p>
<h2 id="刷到的看到的常见题目"><a href="#刷到的看到的常见题目" class="headerlink" title="刷到的看到的常见题目"></a>刷到的看到的常见题目</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/06/算法复习/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构-树"><span class="nav-number">1.</span> <span class="nav-text">数据结构-树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">1.1.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">1.1.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树多少种"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">二叉树多少种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">1.1.2.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中序遍历"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小值"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">insert</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">delete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">1.1.3.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#高度的log证明"><span class="nav-number">1.1.3.0.1.</span> <span class="nav-text">高度的log证明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序统计树"><span class="nav-number">1.1.4.</span> <span class="nav-text">顺序统计树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查找具有给定秩的元素"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">查找具有给定秩的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确定一个元素的秩"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">确定一个元素的秩</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间树（线段树）"><span class="nav-number">1.1.5.</span> <span class="nav-text">区间树（线段树）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#维护"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B树（平衡多路查找树）"><span class="nav-number">1.1.6.</span> <span class="nav-text">B树（平衡多路查找树）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义"><span class="nav-number">1.1.6.0.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入操作"><span class="nav-number">1.1.6.0.2.</span> <span class="nav-text">插入操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除操作"><span class="nav-number">1.1.6.0.3.</span> <span class="nav-text">删除操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">1.1.7.</span> <span class="nav-text">B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与B树区别"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">与B树区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结点结构"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">结点结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树-1"><span class="nav-number">1.1.8.</span> <span class="nav-text">B* 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树"><span class="nav-number">1.1.9.</span> <span class="nav-text">2-3树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4树"><span class="nav-number">1.1.10.</span> <span class="nav-text">2-3-4树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#treap-树堆"><span class="nav-number">1.1.11.</span> <span class="nav-text">treap 树堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刷到的看到的常见题目"><span class="nav-number">1.2.</span> <span class="nav-text">刷到的看到的常见题目</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">57.8k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ywhy-name-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://russell-yy.github.io/2018/10/06/数据结构 树/';
          this.page.identifier = '2018/10/06/数据结构 树/';
          this.page.title = '';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://ywhy-name-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  

















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
